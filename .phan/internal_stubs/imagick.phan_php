<?php
// These stubs were generated by the phan stub generator.
// @phan-stub-for-extension imagick@3.8.0

namespace {
class Imagick implements \Stringable, \Iterator, \Traversable, \Countable {

    // constants
    const COLOR_BLACK = 11;
    const COLOR_BLUE = 12;
    const COLOR_CYAN = 13;
    const COLOR_GREEN = 14;
    const COLOR_RED = 15;
    const COLOR_YELLOW = 16;
    const COLOR_MAGENTA = 17;
    const COLOR_OPACITY = 18;
    const COLOR_ALPHA = 19;
    const COLOR_FUZZ = 20;
    const IMAGICK_EXTNUM = 30800;
    const IMAGICK_EXTVER = '3.8.0';
    const QUANTUM_RANGE = 65535;
    const USE_ZEND_MM = 0;
    const COMPOSITE_DEFAULT = 40;
    const COMPOSITE_UNDEFINED = 0;
    const COMPOSITE_NO = 1;
    const COMPOSITE_ADD = 2;
    const COMPOSITE_ATOP = 3;
    const COMPOSITE_BLEND = 4;
    const COMPOSITE_BUMPMAP = 5;
    const COMPOSITE_CLEAR = 7;
    const COMPOSITE_COLORBURN = 8;
    const COMPOSITE_COLORDODGE = 9;
    const COMPOSITE_COLORIZE = 10;
    const COMPOSITE_COPYBLACK = 11;
    const COMPOSITE_COPYBLUE = 12;
    const COMPOSITE_COPY = 13;
    const COMPOSITE_COPYCYAN = 14;
    const COMPOSITE_COPYGREEN = 15;
    const COMPOSITE_COPYMAGENTA = 16;
    const COMPOSITE_COPYOPACITY = 17;
    const COMPOSITE_COPYRED = 18;
    const COMPOSITE_COPYYELLOW = 19;
    const COMPOSITE_DARKEN = 20;
    const COMPOSITE_DSTATOP = 21;
    const COMPOSITE_DST = 22;
    const COMPOSITE_DSTIN = 23;
    const COMPOSITE_DSTOUT = 24;
    const COMPOSITE_DSTOVER = 25;
    const COMPOSITE_DIFFERENCE = 26;
    const COMPOSITE_DISPLACE = 27;
    const COMPOSITE_DISSOLVE = 28;
    const COMPOSITE_EXCLUSION = 29;
    const COMPOSITE_HARDLIGHT = 30;
    const COMPOSITE_HUE = 31;
    const COMPOSITE_IN = 32;
    const COMPOSITE_LIGHTEN = 33;
    const COMPOSITE_LUMINIZE = 35;
    const COMPOSITE_MINUS = 36;
    const COMPOSITE_MODULATE = 37;
    const COMPOSITE_MULTIPLY = 38;
    const COMPOSITE_OUT = 39;
    const COMPOSITE_OVER = 40;
    const COMPOSITE_OVERLAY = 41;
    const COMPOSITE_PLUS = 42;
    const COMPOSITE_REPLACE = 43;
    const COMPOSITE_SATURATE = 44;
    const COMPOSITE_SCREEN = 45;
    const COMPOSITE_SOFTLIGHT = 46;
    const COMPOSITE_SRCATOP = 47;
    const COMPOSITE_SRC = 48;
    const COMPOSITE_SRCIN = 49;
    const COMPOSITE_SRCOUT = 50;
    const COMPOSITE_SRCOVER = 51;
    const COMPOSITE_SUBTRACT = 52;
    const COMPOSITE_THRESHOLD = 53;
    const COMPOSITE_XOR = 54;
    const COMPOSITE_CHANGEMASK = 6;
    const COMPOSITE_LINEARLIGHT = 34;
    const COMPOSITE_DIVIDE = 55;
    const COMPOSITE_DISTORT = 56;
    const COMPOSITE_BLUR = 57;
    const COMPOSITE_PEGTOPLIGHT = 58;
    const COMPOSITE_VIVIDLIGHT = 59;
    const COMPOSITE_PINLIGHT = 60;
    const COMPOSITE_LINEARDODGE = 61;
    const COMPOSITE_LINEARBURN = 62;
    const COMPOSITE_MATHEMATICS = 63;
    const COMPOSITE_MODULUSADD = 2;
    const COMPOSITE_MODULUSSUBTRACT = 52;
    const COMPOSITE_MINUSDST = 36;
    const COMPOSITE_DIVIDEDST = 55;
    const COMPOSITE_DIVIDESRC = 64;
    const COMPOSITE_MINUSSRC = 65;
    const COMPOSITE_DARKENINTENSITY = 66;
    const COMPOSITE_LIGHTENINTENSITY = 67;
    const COMPOSITE_HARDMIX = 68;
    const COMPOSITE_STEREO = 69;
    const MONTAGEMODE_FRAME = 1;
    const MONTAGEMODE_UNFRAME = 2;
    const MONTAGEMODE_CONCATENATE = 3;
    const STYLE_NORMAL = 1;
    const STYLE_ITALIC = 2;
    const STYLE_OBLIQUE = 3;
    const STYLE_ANY = 4;
    const STYLE_BOLD = 5;
    const FILTER_UNDEFINED = 0;
    const FILTER_POINT = 1;
    const FILTER_BOX = 2;
    const FILTER_TRIANGLE = 3;
    const FILTER_HERMITE = 4;
    const FILTER_HANNING = 5;
    const FILTER_HAMMING = 6;
    const FILTER_BLACKMAN = 7;
    const FILTER_GAUSSIAN = 8;
    const FILTER_QUADRATIC = 9;
    const FILTER_CUBIC = 10;
    const FILTER_CATROM = 11;
    const FILTER_MITCHELL = 12;
    const FILTER_LANCZOS = 22;
    const FILTER_BESSEL = 13;
    const FILTER_SINC = 14;
    const FILTER_KAISER = 16;
    const FILTER_WELSH = 17;
    const FILTER_PARZEN = 18;
    const FILTER_LAGRANGE = 21;
    const FILTER_SENTINEL = 31;
    const FILTER_BOHMAN = 19;
    const FILTER_BARTLETT = 20;
    const FILTER_JINC = 13;
    const FILTER_SINCFAST = 15;
    const FILTER_ROBIDOUX = 26;
    const FILTER_LANCZOSSHARP = 23;
    const FILTER_LANCZOS2 = 24;
    const FILTER_LANCZOS2SHARP = 25;
    const FILTER_ROBIDOUXSHARP = 27;
    const FILTER_COSINE = 28;
    const FILTER_SPLINE = 29;
    const FILTER_LANCZOSRADIUS = 30;
    const IMGTYPE_UNDEFINED = 0;
    const IMGTYPE_BILEVEL = 1;
    const IMGTYPE_GRAYSCALE = 2;
    const IMGTYPE_GRAYSCALEMATTE = 3;
    const IMGTYPE_PALETTE = 4;
    const IMGTYPE_PALETTEMATTE = 5;
    const IMGTYPE_TRUECOLOR = 6;
    const IMGTYPE_TRUECOLORMATTE = 7;
    const IMGTYPE_COLORSEPARATION = 8;
    const IMGTYPE_COLORSEPARATIONMATTE = 9;
    const IMGTYPE_OPTIMIZE = 10;
    const IMGTYPE_PALETTEBILEVELMATTE = 11;
    const RESOLUTION_UNDEFINED = 0;
    const RESOLUTION_PIXELSPERINCH = 1;
    const RESOLUTION_PIXELSPERCENTIMETER = 2;
    const COMPRESSION_UNDEFINED = 0;
    const COMPRESSION_NO = 1;
    const COMPRESSION_BZIP = 2;
    const COMPRESSION_FAX = 6;
    const COMPRESSION_GROUP4 = 7;
    const COMPRESSION_JPEG = 8;
    const COMPRESSION_JPEG2000 = 9;
    const COMPRESSION_LOSSLESSJPEG = 10;
    const COMPRESSION_LZW = 11;
    const COMPRESSION_RLE = 12;
    const COMPRESSION_ZIP = 13;
    const COMPRESSION_DXT1 = 3;
    const COMPRESSION_DXT3 = 4;
    const COMPRESSION_DXT5 = 5;
    const COMPRESSION_ZIPS = 14;
    const COMPRESSION_PIZ = 15;
    const COMPRESSION_PXR24 = 16;
    const COMPRESSION_B44 = 17;
    const COMPRESSION_B44A = 18;
    const COMPRESSION_LZMA = 19;
    const COMPRESSION_JBIG1 = 20;
    const COMPRESSION_JBIG2 = 21;
    const PAINT_POINT = 1;
    const PAINT_REPLACE = 2;
    const PAINT_FLOODFILL = 3;
    const PAINT_FILLTOBORDER = 4;
    const PAINT_RESET = 5;
    const GRAVITY_NORTHWEST = 1;
    const GRAVITY_NORTH = 2;
    const GRAVITY_NORTHEAST = 3;
    const GRAVITY_WEST = 4;
    const GRAVITY_CENTER = 5;
    const GRAVITY_EAST = 6;
    const GRAVITY_SOUTHWEST = 7;
    const GRAVITY_SOUTH = 8;
    const GRAVITY_SOUTHEAST = 9;
    const GRAVITY_FORGET = 0;
    const GRAVITY_STATIC = 10;
    const STRETCH_NORMAL = 1;
    const STRETCH_ULTRACONDENSED = 2;
    const STRETCH_EXTRACONDENSED = 3;
    const STRETCH_CONDENSED = 4;
    const STRETCH_SEMICONDENSED = 5;
    const STRETCH_SEMIEXPANDED = 6;
    const STRETCH_EXPANDED = 7;
    const STRETCH_EXTRAEXPANDED = 8;
    const STRETCH_ULTRAEXPANDED = 9;
    const STRETCH_ANY = 10;
    const ALIGN_UNDEFINED = 0;
    const ALIGN_LEFT = 1;
    const ALIGN_CENTER = 2;
    const ALIGN_RIGHT = 3;
    const DECORATION_NO = 1;
    const DECORATION_UNDERLINE = 2;
    const DECORATION_OVERLINE = 3;
    const DECORATION_LINETROUGH = 4;
    const DECORATION_LINETHROUGH = 4;
    const NOISE_UNIFORM = 1;
    const NOISE_GAUSSIAN = 2;
    const NOISE_MULTIPLICATIVEGAUSSIAN = 3;
    const NOISE_IMPULSE = 4;
    const NOISE_LAPLACIAN = 5;
    const NOISE_POISSON = 6;
    const NOISE_RANDOM = 7;
    const CHANNEL_UNDEFINED = 0;
    const CHANNEL_RED = 1;
    const CHANNEL_GRAY = 1;
    const CHANNEL_CYAN = 1;
    const CHANNEL_GREEN = 2;
    const CHANNEL_MAGENTA = 2;
    const CHANNEL_BLUE = 4;
    const CHANNEL_YELLOW = 4;
    const CHANNEL_ALPHA = 8;
    const CHANNEL_OPACITY = 8;
    const CHANNEL_MATTE = 8;
    const CHANNEL_BLACK = 32;
    const CHANNEL_INDEX = 32;
    const CHANNEL_ALL = 134217727;
    const CHANNEL_DEFAULT = 134217719;
    const CHANNEL_RGBA = 15;
    const CHANNEL_TRUEALPHA = 64;
    const CHANNEL_RGBS = 128;
    const CHANNEL_GRAY_CHANNELS = 128;
    const CHANNEL_SYNC = 256;
    const CHANNEL_COMPOSITES = 47;
    const METRIC_UNDEFINED = 0;
    const METRIC_ABSOLUTEERRORMETRIC = 1;
    const METRIC_MEANABSOLUTEERROR = 2;
    const METRIC_MEANERRORPERPIXELMETRIC = 3;
    const METRIC_MEANSQUAREERROR = 4;
    const METRIC_PEAKABSOLUTEERROR = 5;
    const METRIC_PEAKSIGNALTONOISERATIO = 6;
    const METRIC_ROOTMEANSQUAREDERROR = 7;
    const METRIC_NORMALIZEDCROSSCORRELATIONERRORMETRIC = 8;
    const METRIC_FUZZERROR = 9;
    const METRIC_PERCEPTUALHASH_ERROR = 255;
    const PIXEL_CHAR = 1;
    const PIXELSTORAGE_CHAR = 1;
    const PIXEL_DOUBLE = 2;
    const PIXELSTORAGE_DOUBLE = 2;
    const PIXEL_FLOAT = 3;
    const PIXELSTORAGE_FLOAT = 3;
    const PIXEL_INTEGER = 4;
    const PIXELSTORAGE_INTEGER = 4;
    const PIXEL_LONG = 5;
    const PIXELSTORAGE_LONG = 5;
    const PIXEL_QUANTUM = 6;
    const PIXELSTORAGE_QUANTUM = 6;
    const PIXEL_SHORT = 7;
    const PIXELSTORAGE_SHORT = 7;
    const EVALUATE_UNDEFINED = 0;
    const EVALUATE_ADD = 1;
    const EVALUATE_AND = 2;
    const EVALUATE_DIVIDE = 3;
    const EVALUATE_LEFTSHIFT = 4;
    const EVALUATE_MAX = 5;
    const EVALUATE_MIN = 6;
    const EVALUATE_MULTIPLY = 7;
    const EVALUATE_OR = 8;
    const EVALUATE_RIGHTSHIFT = 9;
    const EVALUATE_SET = 10;
    const EVALUATE_SUBTRACT = 11;
    const EVALUATE_XOR = 12;
    const EVALUATE_POW = 13;
    const EVALUATE_LOG = 14;
    const EVALUATE_THRESHOLD = 15;
    const EVALUATE_THRESHOLDBLACK = 16;
    const EVALUATE_THRESHOLDWHITE = 17;
    const EVALUATE_GAUSSIANNOISE = 18;
    const EVALUATE_IMPULSENOISE = 19;
    const EVALUATE_LAPLACIANNOISE = 20;
    const EVALUATE_MULTIPLICATIVENOISE = 21;
    const EVALUATE_POISSONNOISE = 22;
    const EVALUATE_UNIFORMNOISE = 23;
    const EVALUATE_COSINE = 24;
    const EVALUATE_SINE = 25;
    const EVALUATE_ADDMODULUS = 26;
    const EVALUATE_MEAN = 27;
    const EVALUATE_ABS = 28;
    const EVALUATE_EXPONENTIAL = 29;
    const EVALUATE_MEDIAN = 30;
    const EVALUATE_SUM = 31;
    const EVALUATE_ROOT_MEAN_SQUARE = 32;
    const COLORSPACE_UNDEFINED = 0;
    const COLORSPACE_RGB = 1;
    const COLORSPACE_GRAY = 2;
    const COLORSPACE_TRANSPARENT = 3;
    const COLORSPACE_OHTA = 4;
    const COLORSPACE_LAB = 5;
    const COLORSPACE_XYZ = 6;
    const COLORSPACE_YCBCR = 7;
    const COLORSPACE_YCC = 8;
    const COLORSPACE_YIQ = 9;
    const COLORSPACE_YPBPR = 10;
    const COLORSPACE_YUV = 11;
    const COLORSPACE_CMYK = 12;
    const COLORSPACE_SRGB = 13;
    const COLORSPACE_HSB = 14;
    const COLORSPACE_HSL = 15;
    const COLORSPACE_HWB = 16;
    const COLORSPACE_REC601LUMA = 17;
    const COLORSPACE_REC709LUMA = 19;
    const COLORSPACE_LOG = 21;
    const COLORSPACE_CMY = 22;
    const COLORSPACE_LUV = 23;
    const COLORSPACE_HCL = 24;
    const COLORSPACE_LCH = 25;
    const COLORSPACE_LMS = 26;
    const COLORSPACE_LCHAB = 27;
    const COLORSPACE_LCHUV = 28;
    const COLORSPACE_SCRGB = 29;
    const COLORSPACE_HSI = 30;
    const COLORSPACE_HSV = 31;
    const COLORSPACE_HCLP = 32;
    const COLORSPACE_YDBDR = 33;
    const COLORSPACE_REC601YCBCR = 18;
    const COLORSPACE_REC709YCBCR = 20;
    const COLORSPACE_XYY = 34;
    const COLORSPACE_LINEARGRAY = 35;
    const VIRTUALPIXELMETHOD_UNDEFINED = 0;
    const VIRTUALPIXELMETHOD_BACKGROUND = 1;
    const VIRTUALPIXELMETHOD_CONSTANT = 2;
    const VIRTUALPIXELMETHOD_EDGE = 4;
    const VIRTUALPIXELMETHOD_MIRROR = 5;
    const VIRTUALPIXELMETHOD_TILE = 7;
    const VIRTUALPIXELMETHOD_TRANSPARENT = 8;
    const VIRTUALPIXELMETHOD_MASK = 9;
    const VIRTUALPIXELMETHOD_BLACK = 10;
    const VIRTUALPIXELMETHOD_GRAY = 11;
    const VIRTUALPIXELMETHOD_WHITE = 12;
    const VIRTUALPIXELMETHOD_HORIZONTALTILE = 13;
    const VIRTUALPIXELMETHOD_VERTICALTILE = 14;
    const VIRTUALPIXELMETHOD_HORIZONTALTILEEDGE = 15;
    const VIRTUALPIXELMETHOD_VERTICALTILEEDGE = 16;
    const VIRTUALPIXELMETHOD_CHECKERTILE = 17;
    const VIRTUALPIXELMETHOD_DITHER = 3;
    const VIRTUALPIXELMETHOD_RANDOM = 6;
    const PREVIEW_UNDEFINED = 0;
    const PREVIEW_ROTATE = 1;
    const PREVIEW_SHEAR = 2;
    const PREVIEW_ROLL = 3;
    const PREVIEW_HUE = 4;
    const PREVIEW_SATURATION = 5;
    const PREVIEW_BRIGHTNESS = 6;
    const PREVIEW_GAMMA = 7;
    const PREVIEW_SPIFF = 8;
    const PREVIEW_DULL = 9;
    const PREVIEW_GRAYSCALE = 10;
    const PREVIEW_QUANTIZE = 11;
    const PREVIEW_DESPECKLE = 12;
    const PREVIEW_REDUCENOISE = 13;
    const PREVIEW_ADDNOISE = 14;
    const PREVIEW_SHARPEN = 15;
    const PREVIEW_BLUR = 16;
    const PREVIEW_THRESHOLD = 17;
    const PREVIEW_EDGEDETECT = 18;
    const PREVIEW_SPREAD = 19;
    const PREVIEW_SOLARIZE = 20;
    const PREVIEW_SHADE = 21;
    const PREVIEW_RAISE = 22;
    const PREVIEW_SEGMENT = 23;
    const PREVIEW_SWIRL = 24;
    const PREVIEW_IMPLODE = 25;
    const PREVIEW_WAVE = 26;
    const PREVIEW_OILPAINT = 27;
    const PREVIEW_CHARCOALDRAWING = 28;
    const PREVIEW_JPEG = 29;
    const RENDERINGINTENT_UNDEFINED = 0;
    const RENDERINGINTENT_SATURATION = 1;
    const RENDERINGINTENT_PERCEPTUAL = 2;
    const RENDERINGINTENT_ABSOLUTE = 3;
    const RENDERINGINTENT_RELATIVE = 4;
    const INTERLACE_UNDEFINED = 0;
    const INTERLACE_NO = 1;
    const INTERLACE_LINE = 2;
    const INTERLACE_PLANE = 3;
    const INTERLACE_PARTITION = 4;
    const INTERLACE_GIF = 5;
    const INTERLACE_JPEG = 6;
    const INTERLACE_PNG = 7;
    const FILLRULE_UNDEFINED = 0;
    const FILLRULE_EVENODD = 1;
    const FILLRULE_NONZERO = 2;
    const PATHUNITS_UNDEFINED = 0;
    const PATHUNITS_USERSPACE = 1;
    const PATHUNITS_USERSPACEONUSE = 2;
    const PATHUNITS_OBJECTBOUNDINGBOX = 3;
    const LINECAP_UNDEFINED = 0;
    const LINECAP_BUTT = 1;
    const LINECAP_ROUND = 2;
    const LINECAP_SQUARE = 3;
    const LINEJOIN_UNDEFINED = 0;
    const LINEJOIN_MITER = 1;
    const LINEJOIN_ROUND = 2;
    const LINEJOIN_BEVEL = 3;
    const RESOURCETYPE_UNDEFINED = 0;
    const RESOURCETYPE_AREA = 1;
    const RESOURCETYPE_DISK = 2;
    const RESOURCETYPE_FILE = 3;
    const RESOURCETYPE_MAP = 4;
    const RESOURCETYPE_MEMORY = 5;
    const RESOURCETYPE_TIME = 7;
    const RESOURCETYPE_THROTTLE = 8;
    const RESOURCETYPE_THREAD = 6;
    const RESOURCETYPE_WIDTH = 9;
    const RESOURCETYPE_HEIGHT = 10;
    const RESOURCETYPE_LISTLENGTH = 11;
    const DISPOSE_UNRECOGNIZED = 0;
    const DISPOSE_UNDEFINED = 0;
    const DISPOSE_NONE = 1;
    const DISPOSE_BACKGROUND = 2;
    const DISPOSE_PREVIOUS = 3;
    const INTERPOLATE_UNDEFINED = 0;
    const INTERPOLATE_AVERAGE = 1;
    const INTERPOLATE_BICUBIC = 2;
    const INTERPOLATE_BILINEAR = 3;
    const INTERPOLATE_FILTER = 4;
    const INTERPOLATE_INTEGER = 5;
    const INTERPOLATE_MESH = 6;
    const INTERPOLATE_NEARESTNEIGHBOR = 7;
    const INTERPOLATE_SPLINE = 8;
    const INTERPOLATE_AVERAGE_9 = 9;
    const INTERPOLATE_AVERAGE_16 = 10;
    const INTERPOLATE_BLEND = 11;
    const INTERPOLATE_BACKGROUND_COLOR = 12;
    const INTERPOLATE_CATROM = 13;
    const LAYERMETHOD_UNDEFINED = 0;
    const LAYERMETHOD_COALESCE = 1;
    const LAYERMETHOD_COMPAREANY = 2;
    const LAYERMETHOD_COMPARECLEAR = 3;
    const LAYERMETHOD_COMPAREOVERLAY = 4;
    const LAYERMETHOD_DISPOSE = 5;
    const LAYERMETHOD_OPTIMIZE = 6;
    const LAYERMETHOD_OPTIMIZEPLUS = 8;
    const LAYERMETHOD_OPTIMIZETRANS = 9;
    const LAYERMETHOD_COMPOSITE = 12;
    const LAYERMETHOD_OPTIMIZEIMAGE = 7;
    const LAYERMETHOD_REMOVEDUPS = 10;
    const LAYERMETHOD_REMOVEZERO = 11;
    const LAYERMETHOD_TRIMBOUNDS = 16;
    const ORIENTATION_UNDEFINED = 0;
    const ORIENTATION_TOPLEFT = 1;
    const ORIENTATION_TOPRIGHT = 2;
    const ORIENTATION_BOTTOMRIGHT = 3;
    const ORIENTATION_BOTTOMLEFT = 4;
    const ORIENTATION_LEFTTOP = 5;
    const ORIENTATION_RIGHTTOP = 6;
    const ORIENTATION_RIGHTBOTTOM = 7;
    const ORIENTATION_LEFTBOTTOM = 8;
    const DISTORTION_UNDEFINED = 0;
    const DISTORTION_AFFINE = 1;
    const DISTORTION_AFFINEPROJECTION = 2;
    const DISTORTION_ARC = 9;
    const DISTORTION_BILINEAR = 6;
    const DISTORTION_PERSPECTIVE = 4;
    const DISTORTION_PERSPECTIVEPROJECTION = 5;
    const DISTORTION_SCALEROTATETRANSLATE = 3;
    const DISTORTION_POLYNOMIAL = 8;
    const DISTORTION_POLAR = 10;
    const DISTORTION_DEPOLAR = 11;
    const DISTORTION_BARREL = 14;
    const DISTORTION_SHEPARDS = 16;
    const DISTORTION_SENTINEL = 18;
    const DISTORTION_BARRELINVERSE = 15;
    const DISTORTION_BILINEARFORWARD = 6;
    const DISTORTION_BILINEARREVERSE = 7;
    const DISTORTION_RESIZE = 17;
    const DISTORTION_CYLINDER2PLANE = 12;
    const DISTORTION_PLANE2CYLINDER = 13;
    const LAYERMETHOD_MERGE = 13;
    const LAYERMETHOD_FLATTEN = 14;
    const LAYERMETHOD_MOSAIC = 15;
    const ALPHACHANNEL_ACTIVATE = 1;
    const ALPHACHANNEL_RESET = 7;
    const ALPHACHANNEL_SET = 8;
    const ALPHACHANNEL_UNDEFINED = 0;
    const ALPHACHANNEL_COPY = 3;
    const ALPHACHANNEL_DEACTIVATE = 4;
    const ALPHACHANNEL_EXTRACT = 5;
    const ALPHACHANNEL_OPAQUE = 6;
    const ALPHACHANNEL_SHAPE = 9;
    const ALPHACHANNEL_TRANSPARENT = 10;
    const ALPHACHANNEL_ASSOCIATE = 13;
    const ALPHACHANNEL_DISSOCIATE = 14;
    const SPARSECOLORMETHOD_UNDEFINED = 0;
    const SPARSECOLORMETHOD_BARYCENTRIC = 1;
    const SPARSECOLORMETHOD_BILINEAR = 7;
    const SPARSECOLORMETHOD_POLYNOMIAL = 8;
    const SPARSECOLORMETHOD_SPEPARDS = 16;
    const SPARSECOLORMETHOD_VORONOI = 18;
    const SPARSECOLORMETHOD_INVERSE = 19;
    const SPARSECOLORMETHOD_MANHATTAN = 20;
    const DITHERMETHOD_UNDEFINED = 0;
    const DITHERMETHOD_NO = 1;
    const DITHERMETHOD_RIEMERSMA = 2;
    const DITHERMETHOD_FLOYDSTEINBERG = 3;
    const FUNCTION_UNDEFINED = 0;
    const FUNCTION_POLYNOMIAL = 1;
    const FUNCTION_SINUSOID = 2;
    const ALPHACHANNEL_BACKGROUND = 2;
    const FUNCTION_ARCSIN = 3;
    const FUNCTION_ARCTAN = 4;
    const ALPHACHANNEL_FLATTEN = 11;
    const ALPHACHANNEL_REMOVE = 12;
    const STATISTIC_GRADIENT = 1;
    const STATISTIC_MAXIMUM = 2;
    const STATISTIC_MEAN = 3;
    const STATISTIC_MEDIAN = 4;
    const STATISTIC_MINIMUM = 5;
    const STATISTIC_MODE = 6;
    const STATISTIC_NONPEAK = 7;
    const STATISTIC_STANDARD_DEVIATION = 8;
    const STATISTIC_ROOT_MEAN_SQUARE = 9;
    const MORPHOLOGY_CONVOLVE = 1;
    const MORPHOLOGY_CORRELATE = 2;
    const MORPHOLOGY_ERODE = 3;
    const MORPHOLOGY_DILATE = 4;
    const MORPHOLOGY_ERODE_INTENSITY = 5;
    const MORPHOLOGY_DILATE_INTENSITY = 6;
    const MORPHOLOGY_DISTANCE = 7;
    const MORPHOLOGY_OPEN = 8;
    const MORPHOLOGY_CLOSE = 9;
    const MORPHOLOGY_OPEN_INTENSITY = 10;
    const MORPHOLOGY_CLOSE_INTENSITY = 11;
    const MORPHOLOGY_SMOOTH = 12;
    const MORPHOLOGY_EDGE_IN = 13;
    const MORPHOLOGY_EDGE_OUT = 14;
    const MORPHOLOGY_EDGE = 15;
    const MORPHOLOGY_TOP_HAT = 16;
    const MORPHOLOGY_BOTTOM_HAT = 17;
    const MORPHOLOGY_HIT_AND_MISS = 18;
    const MORPHOLOGY_THINNING = 19;
    const MORPHOLOGY_THICKEN = 20;
    const MORPHOLOGY_VORONOI = 21;
    const MORPHOLOGY_ITERATIVE = 22;
    const KERNEL_UNITY = 1;
    const KERNEL_GAUSSIAN = 2;
    const KERNEL_DIFFERENCE_OF_GAUSSIANS = 3;
    const KERNEL_LAPLACIAN_OF_GAUSSIANS = 4;
    const KERNEL_BLUR = 5;
    const KERNEL_COMET = 6;
    const KERNEL_LAPLACIAN = 7;
    const KERNEL_SOBEL = 8;
    const KERNEL_FREI_CHEN = 9;
    const KERNEL_ROBERTS = 10;
    const KERNEL_PREWITT = 11;
    const KERNEL_COMPASS = 12;
    const KERNEL_KIRSCH = 13;
    const KERNEL_DIAMOND = 14;
    const KERNEL_SQUARE = 15;
    const KERNEL_RECTANGLE = 16;
    const KERNEL_OCTAGON = 17;
    const KERNEL_DISK = 18;
    const KERNEL_PLUS = 19;
    const KERNEL_CROSS = 20;
    const KERNEL_RING = 21;
    const KERNEL_PEAKS = 22;
    const KERNEL_EDGES = 23;
    const KERNEL_CORNERS = 24;
    const KERNEL_DIAGONALS = 25;
    const KERNEL_LINE_ENDS = 26;
    const KERNEL_LINE_JUNCTIONS = 27;
    const KERNEL_RIDGES = 28;
    const KERNEL_CONVEX_HULL = 29;
    const KERNEL_THIN_SE = 30;
    const KERNEL_SKELETON = 31;
    const KERNEL_CHEBYSHEV = 32;
    const KERNEL_MANHATTAN = 33;
    const KERNEL_OCTAGONAL = 34;
    const KERNEL_EUCLIDEAN = 35;
    const KERNEL_USER_DEFINED = 36;
    const KERNEL_BINOMIAL = 37;
    const DIRECTION_LEFT_TO_RIGHT = 2;
    const DIRECTION_RIGHT_TO_LEFT = 1;
    const NORMALIZE_KERNEL_NONE = 0;
    const NORMALIZE_KERNEL_VALUE = 8192;
    const NORMALIZE_KERNEL_CORRELATE = 65536;
    const NORMALIZE_KERNEL_PERCENT = 4096;

    // methods
    public function optimizeImageLayers() : \Imagick {}
    public function compareImageLayers(int $metric) : \Imagick {}
    public function pingImageBlob(string $image) : bool {}
    public function pingImageFile(mixed $filehandle, ?string $filename = null) : bool {}
    public function transposeImage() : bool {}
    public function transverseImage() : bool {}
    public function trimImage(float $fuzz) : bool {}
    public function waveImage(float $amplitude, float $length) : bool {}
    public function vignetteImage(float $black_point, float $white_point, int $x, int $y) : bool {}
    public function uniqueImageColors() : bool {}
    public function getImageMatte() : bool {}
    public function setImageMatte(bool $matte) : bool {}
    public function adaptiveResizeImage(int $columns, int $rows, bool $bestfit = false, bool $legacy = false) : bool {}
    public function sketchImage(float $radius, float $sigma, float $angle) : bool {}
    public function shadeImage(bool $gray, float $azimuth, float $elevation) : bool {}
    public function getSizeOffset() : int {}
    public function setSizeOffset(int $columns, int $rows, int $offset) : bool {}
    public function adaptiveBlurImage(float $radius, float $sigma, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function contrastStretchImage(float $black_point, float $white_point, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function adaptiveSharpenImage(float $radius, float $sigma, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function randomThresholdImage(float $low, float $high, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function roundCornersImage(float $x_rounding, float $y_rounding, float $stroke_width = 10, float $displace = 5, float $size_correction = -6) : bool {}
    public function roundCorners(float $x_rounding, float $y_rounding, float $stroke_width = 10, float $displace = 5, float $size_correction = -6) : bool {}
    public function setIteratorIndex(int $index) : bool {}
    public function getIteratorIndex() : int {}
    public function transformImage(string $crop, string $geometry) : \Imagick {}
    public function setImageOpacity(float $opacity) : bool {}
    public function orderedPosterizeImage(string $threshold_map, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function polaroidImage(\ImagickDraw $settings, float $angle) : bool {}
    public function getImageProperty(string $name) : string {}
    public function setImageProperty(string $name, string $value) : bool {}
    public function deleteImageProperty(string $name) : bool {}
    public function identifyFormat(string $format) : string {}
    public function setImageInterpolateMethod(int $method) : bool {}
    public function getImageInterpolateMethod() : int {}
    public function linearStretchImage(float $black_point, float $white_point) : bool {}
    public function getImageLength() : int {}
    public function extentImage(int $width, int $height, int $x, int $y) : bool {}
    public function getImageOrientation() : int {}
    public function setImageOrientation(int $orientation) : bool {}
    public function paintFloodfillImage(\ImagickPixel|string $fill_color, float $fuzz, \ImagickPixel|string $border_color, int $x, int $y, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function clutImage(\Imagick $lookup_table, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function getImageProperties(string $pattern = '*', bool $include_values = true) : array {}
    public function getImageProfiles(string $pattern = '*', bool $include_values = true) : array {}
    public function distortImage(int $distortion, array $arguments, bool $bestfit) : bool {}
    public function writeImageFile(mixed $filehandle, ?string $format = null) : bool {}
    public function writeImagesFile(mixed $filehandle, ?string $format = null) : bool {}
    public function resetImagePage(string $page) : bool {}
    public function setImageClipMask(\Imagick $clip_mask) : bool {}
    public function getImageClipMask() : \Imagick {}
    public function animateImages(string $x_server) : bool {}
    public function recolorImage(array $matrix) : bool {}
    public function setFont(string $font) : bool {}
    public function getFont() : string {}
    public function setPointSize(float $point_size) : bool {}
    public function getPointSize() : float {}
    public function mergeImageLayers(int $layermethod) : \Imagick {}
    public function setImageAlphaChannel(int $alphachannel) : bool {}
    public function floodfillPaintImage(\ImagickPixel|string $fill_color, float $fuzz, \ImagickPixel|string $border_color, int $x, int $y, bool $invert, ?int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function opaquePaintImage(\ImagickPixel|string $target_color, \ImagickPixel|string $fill_color, float $fuzz, bool $invert, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function transparentPaintImage(\ImagickPixel|string $target_color, float $alpha, float $fuzz, bool $invert) : bool {}
    public function liquidRescaleImage(int $width, int $height, float $delta_x, float $rigidity) : bool {}
    public function encipherImage(string $passphrase) : bool {}
    public function decipherImage(string $passphrase) : bool {}
    public function setGravity(int $gravity) : bool {}
    public function getGravity() : int {}
    public function getImageChannelRange(int $channel) : array {}
    public function getImageAlphaChannel() : bool {}
    public function getImageChannelDistortions(\Imagick $reference_image, int $metric, int $channel = \Imagick::CHANNEL_DEFAULT) : float {}
    public function setImageGravity(int $gravity) : bool {}
    public function getImageGravity() : int {}
    public function importImagePixels(int $x, int $y, int $width, int $height, string $map, int $pixelstorage, array $pixels) : bool {}
    public function deskewImage(float $threshold) : bool {}
    public function segmentImage(int $colorspace, float $cluster_threshold, float $smooth_threshold, bool $verbose = false) : bool {}
    public function sparseColorImage(int $sparsecolormethod, array $arguments, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function remapImage(\Imagick $replacement, int $dither_method) : bool {}
    public function exportImagePixels(int $x, int $y, int $width, int $height, string $map, int $pixelstorage) : array {}
    public function getImageChannelKurtosis(int $channel = \Imagick::CHANNEL_DEFAULT) : array {}
    public function functionImage(int $function, array $parameters, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function transformImageColorspace(int $colorspace) : bool {}
    public function haldClutImage(\Imagick $clut, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function autoLevelImage(int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function blueShiftImage(float $factor = 1.5) : bool {}
    public function getImageArtifact(string $artifact) : ?string {}
    public function setImageArtifact(string $artifact, ?string $value) : bool {}
    public function deleteImageArtifact(string $artifact) : bool {}
    public function getColorspace() : int {}
    public function setColorspace(int $colorspace) : bool {}
    public function clampImage(int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function smushImages(bool $stack, int $offset) : \Imagick {}
    public function __construct(array|float|int|null|string $files = null) {}
    public function __toString() : string {}
    public function count(int $mode = 0) : int {}
    public function getPixelIterator() : \ImagickPixelIterator {}
    public function getPixelRegionIterator(int $x, int $y, int $columns, int $rows) : \ImagickPixelIterator {}
    public function readImage(string $filename) : bool {}
    public function readImages(array $filenames) : bool {}
    public function readImageBlob(string $image, ?string $filename = null) : bool {}
    public function setImageFormat(string $format) : bool {}
    public function scaleImage(int $columns, int $rows, bool $bestfit = false, bool $legacy = false) : bool {}
    public function writeImage(?string $filename = null) : bool {}
    public function writeImages(string $filename, bool $adjoin) : bool {}
    public function blurImage(float $radius, float $sigma, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function thumbnailImage(?int $columns, ?int $rows, bool $bestfit = false, bool $fill = false, bool $legacy = false) : bool {}
    public function cropThumbnailImage(int $width, int $height, bool $legacy = false) : bool {}
    public function getImageFilename() : string {}
    public function setImageFilename(string $filename) : bool {}
    public function getImageFormat() : string {}
    public function getImageMimeType() : string {}
    public function removeImage() : bool {}
    public function destroy() : bool {}
    public function clear() : bool {}
    public function clone() : \Imagick {}
    public function getImageSize() : int {}
    public function getImageBlob() : ?string {}
    public function getImagesBlob() : string {}
    public function setFirstIterator() : bool {}
    public function setLastIterator() : bool {}
    public function resetIterator() : void {}
    public function previousImage() : bool {}
    public function nextImage() : bool {}
    public function hasPreviousImage() : bool {}
    public function hasNextImage() : bool {}
    public function setImageIndex(int $index) : bool {}
    public function getImageIndex() : int {}
    public function commentImage(string $comment) : bool {}
    public function cropImage(int $width, int $height, int $x, int $y) : bool {}
    public function labelImage(string $label) : bool {}
    public function getImageGeometry() : array {}
    public function drawImage(\ImagickDraw $drawing) : bool {}
    public function setImageCompressionQuality(int $quality) : bool {}
    public function getImageCompressionQuality() : int {}
    public function setImageCompression(int $compression) : bool {}
    public function getImageCompression() : int {}
    public function annotateImage(\ImagickDraw $settings, float $x, float $y, float $angle, string $text) : bool {}
    public function compositeImage(\Imagick $composite_image, int $composite, int $x, int $y, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function modulateImage(float $brightness, float $saturation, float $hue) : bool {}
    public function getImageColors() : int {}
    public function montageImage(\ImagickDraw $settings, string $tile_geometry, string $thumbnail_geometry, int $monatgemode, string $frame) : \Imagick {}
    public function identifyImage(bool $append_raw_output = false) : array {}
    public function thresholdImage(float $threshold, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function adaptiveThresholdImage(int $width, int $height, int $offset) : bool {}
    public function blackThresholdImage(\ImagickPixel|string $threshold_color) : bool {}
    public function whiteThresholdImage(\ImagickPixel|string $threshold_color) : bool {}
    public function appendImages(bool $stack) : \Imagick {}
    public function charcoalImage(float $radius, float $sigma) : bool {}
    public function normalizeImage(int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function oilPaintImage(float $radius) : bool {}
    public function posterizeImage(int $levels, bool $dither) : bool {}
    public function radialBlurImage(float $angle, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function raiseImage(int $width, int $height, int $x, int $y, bool $raise) : bool {}
    public function resampleImage(float $x_resolution, float $y_resolution, int $filter, float $blur) : bool {}
    public function resizeImage(int $columns, int $rows, int $filter, float $blur, bool $bestfit = false, bool $legacy = false) : bool {}
    public function rollImage(int $x, int $y) : bool {}
    public function rotateImage(\ImagickPixel|string $background_color, float $degrees) : bool {}
    public function sampleImage(int $columns, int $rows) : bool {}
    public function solarizeImage(int $threshold) : bool {}
    public function shadowImage(float $opacity, float $sigma, int $x, int $y) : bool {}
    public function setImageAttribute(string $key, string $value) : bool {}
    public function setImageBackgroundColor(\ImagickPixel|string $background_color) : bool {}
    public function setImageCompose(int $compose) : bool {}
    public function setImageDelay(int $delay) : bool {}
    public function setImageDepth(int $depth) : bool {}
    public function setImageGamma(float $gamma) : bool {}
    public function setImageIterations(int $iterations) : bool {}
    public function setImageMatteColor(\ImagickPixel|string $matte_color) : bool {}
    public function setImagePage(int $width, int $height, int $x, int $y) : bool {}
    public function setImageProgressMonitor(string $filename) : bool {}
    public function setProgressMonitor(callable $callback) : bool {}
    public function setImageResolution(float $x_resolution, float $y_resolution) : bool {}
    public function setImageScene(int $scene) : bool {}
    public function setImageTicksPerSecond(int $ticks_per_second) : bool {}
    public function setImageType(int $image_type) : bool {}
    public function setImageUnits(int $units) : bool {}
    public function sharpenImage(float $radius, float $sigma, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function shaveImage(int $columns, int $rows) : bool {}
    public function shearImage(\ImagickPixel|string $background_color, float $x_shear, float $y_shear) : bool {}
    public function spliceImage(int $width, int $height, int $x, int $y) : bool {}
    public function pingImage(string $filename) : bool {}
    public function readImageFile(mixed $filehandle, ?string $filename = null) : bool {}
    public function displayImage(string $servername) : bool {}
    public function displayImages(string $servername) : bool {}
    public function spreadImage(float $radius) : bool {}
    public function swirlImage(float $degrees) : bool {}
    public function stripImage() : bool {}
    public static function queryFormats(string $pattern = '*') : array {}
    public static function queryFonts(string $pattern = '*') : array {}
    public function queryFontMetrics(\ImagickDraw $settings, string $text, ?bool $multiline = null) : array {}
    public function steganoImage(\Imagick $watermark, int $offset) : \Imagick {}
    public function addNoiseImage(int $noise, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function motionBlurImage(float $radius, float $sigma, float $angle, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function mosaicImages() : \Imagick {}
    public function morphImages(int $number_frames) : \Imagick {}
    public function minifyImage() : bool {}
    public function affineTransformImage(\ImagickDraw $settings) : bool {}
    public function averageImages() : \Imagick {}
    public function borderImage(\ImagickPixel|string $border_color, int $width, int $height) : bool {}
    public static function calculateCrop(int $original_width, int $original_height, int $desired_width, int $desired_height, bool $legacy = false) : array {}
    public function chopImage(int $width, int $height, int $x, int $y) : bool {}
    public function clipImage() : bool {}
    public function clipPathImage(string $pathname, bool $inside) : bool {}
    public function clipImagePath(string $pathname, bool $inside) : void {}
    public function coalesceImages() : \Imagick {}
    public function colorFloodfillImage(\ImagickPixel|string $fill_color, float $fuzz, \ImagickPixel|string $border_color, int $x, int $y) : bool {}
    public function colorizeImage(\ImagickPixel|string $colorize_color, \ImagickPixel|false|string $opacity_color, ?bool $legacy = false) : bool {}
    public function compareImageChannels(\Imagick $reference, int $channel, int $metric) : array {}
    public function compareImages(\Imagick $reference, int $metric) : array {}
    public function contrastImage(bool $sharpen) : bool {}
    public function combineImages(int $colorspace) : \Imagick {}
    public function convolveImage(array $kernel, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function cycleColormapImage(int $displace) : bool {}
    public function deconstructImages() : \Imagick {}
    public function despeckleImage() : bool {}
    public function edgeImage(float $radius) : bool {}
    public function embossImage(float $radius, float $sigma) : bool {}
    public function enhanceImage() : bool {}
    public function equalizeImage() : bool {}
    public function evaluateImage(int $evaluate, float $constant, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function evaluateImages(int $evaluate) : \Imagick {}
    public function flattenImages() : \Imagick {}
    public function flipImage() : bool {}
    public function flopImage() : bool {}
    public function forwardFourierTransformImage(bool $magnitude) : bool {}
    public function frameImage(\ImagickPixel|string $matte_color, int $width, int $height, int $inner_bevel, int $outer_bevel) : bool {}
    public function fxImage(string $expression, int $channel = \Imagick::CHANNEL_DEFAULT) : \Imagick {}
    public function gammaImage(float $gamma, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function gaussianBlurImage(float $radius, float $sigma, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function getImageAttribute(string $key) : string {}
    public function getImageBackgroundColor() : \ImagickPixel {}
    public function getImageBluePrimary() : array {}
    public function getImageBorderColor() : \ImagickPixel {}
    public function getImageChannelDepth(int $channel) : int {}
    public function getImageChannelDistortion(\Imagick $reference, int $channel, int $metric) : float {}
    public function getImageChannelExtrema(int $channel) : array {}
    public function getImageChannelMean(int $channel) : array {}
    public function getImageChannelStatistics() : array {}
    public function getImageColormapColor(int $index) : \ImagickPixel {}
    public function getImageColorspace() : int {}
    public function getImageCompose() : int {}
    public function getImageDelay() : int {}
    public function getImageDepth() : int {}
    public function getImageDistortion(\Imagick $reference, int $metric) : float {}
    public function getImageExtrema() : array {}
    public function getImageDispose() : int {}
    public function getImageGamma() : float {}
    public function getImageGreenPrimary() : array {}
    public function getImageHeight() : int {}
    public function getImageHistogram() : array {}
    public function getImageInterlaceScheme() : int {}
    public function getImageIterations() : int {}
    public function getImageMatteColor() : \ImagickPixel {}
    public function getImagePage() : array {}
    public function getImagePixelColor(int $x, int $y) : \ImagickPixel {}
    public function getImageProfile(string $name) : string {}
    public function getImageRedPrimary() : array {}
    public function getImageRenderingIntent() : int {}
    public function getImageResolution() : array {}
    public function getImageScene() : int {}
    public function getImageSignature() : string {}
    public function getImageTicksPerSecond() : int {}
    public function getImageType() : int {}
    public function getImageUnits() : int {}
    public function getImageVirtualPixelMethod() : int {}
    public function getImageWhitePoint() : array {}
    public function getImageWidth() : int {}
    public function getNumberImages() : int {}
    public function getImageTotalInkDensity() : float {}
    public function getImageRegion(int $width, int $height, int $x, int $y) : \Imagick {}
    public function implodeImage(float $radius) : bool {}
    public function inverseFourierTransformImage(\Imagick $complement, bool $magnitude) : bool {}
    public function levelImage(float $black_point, float $gamma, float $white_point, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function magnifyImage() : bool {}
    public function mapImage(\Imagick $map, bool $dither) : bool {}
    public function matteFloodfillImage(float $alpha, float $fuzz, \ImagickPixel|string $border_color, int $x, int $y) : bool {}
    public function medianFilterImage(float $radius) : bool {}
    public function negateImage(bool $gray, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function paintOpaqueImage(\ImagickPixel|string $target_color, \ImagickPixel|string $fill_color, float $fuzz, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function paintTransparentImage(\ImagickPixel|string $target_color, float $alpha, float $fuzz) : bool {}
    public function previewImages(int $preview) : bool {}
    public function profileImage(string $name, ?string $profile) : bool {}
    public function quantizeImage(int $number_colors, int $colorspace, int $tree_depth, bool $dither, bool $measure_error) : bool {}
    public function quantizeImages(int $number_colors, int $colorspace, int $tree_depth, bool $dither, bool $measure_error) : bool {}
    public function reduceNoiseImage(float $radius) : bool {}
    public function removeImageProfile(string $name) : string {}
    public function separateImageChannel(int $channel) : bool {}
    public function sepiaToneImage(float $threshold) : bool {}
    public function setImageBias(float $bias) : bool {}
    public function setImageBiasQuantum(string $bias) : void {}
    public function setImageBluePrimary(float $x, float $y) : bool {}
    public function setImageBorderColor(\ImagickPixel|string $border_color) : bool {}
    public function setImageChannelDepth(int $channel, int $depth) : bool {}
    public function setImageColormapColor(int $index, \ImagickPixel|string $color) : bool {}
    public function setImageColorspace(int $colorspace) : bool {}
    public function setImageDispose(int $dispose) : bool {}
    public function setImageExtent(int $columns, int $rows) : bool {}
    public function setImageGreenPrimary(float $x, float $y) : bool {}
    public function setImageInterlaceScheme(int $interlace) : bool {}
    public function setImageProfile(string $name, string $profile) : bool {}
    public function setImageRedPrimary(float $x, float $y) : bool {}
    public function setImageRenderingIntent(int $rendering_intent) : bool {}
    public function setImageVirtualPixelMethod(int $method) : bool {}
    public function setImageWhitePoint(float $x, float $y) : bool {}
    public function sigmoidalContrastImage(bool $sharpen, float $alpha, float $beta, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function stereoImage(\Imagick $offset_image) : bool {}
    public function textureImage(\Imagick $texture) : \Imagick {}
    public function tintImage(\ImagickPixel|string $tint_color, \ImagickPixel|string $opacity_color, bool $legacy = false) : bool {}
    public function unsharpMaskImage(float $radius, float $sigma, float $amount, float $threshold, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function getImage() : \Imagick {}
    public function addImage(\Imagick $image) : bool {}
    public function setImage(\Imagick $image) : bool {}
    public function newImage(int $columns, int $rows, \ImagickPixel|string $background_color, ?string $format = null) : bool {}
    public function newPseudoImage(int $columns, int $rows, string $pseudo_format) : bool {}
    public function getCompression() : int {}
    public function getCompressionQuality() : int {}
    public static function getCopyright() : string {}
    public static function getConfigureOptions(string $pattern = '*') : array {}
    public static function getFeatures() : string {}
    public function getFilename() : string {}
    public function getFormat() : string {}
    public static function getHomeURL() : string {}
    public function getInterlaceScheme() : int {}
    public function getOption(string $key) : string {}
    public static function getPackageName() : string {}
    public function getPage() : array {}
    public static function getQuantum() : int {}
    public static function getHdriEnabled() : bool {}
    public static function getQuantumDepth() : array {}
    public static function getQuantumRange() : array {}
    public static function getReleaseDate() : string {}
    public static function getResource(int $type) : int {}
    public static function getResourceLimit(int $type) : float {}
    public function getSamplingFactors() : array {}
    public function getSize() : array {}
    public static function getVersion() : array {}
    public function setBackgroundColor(\ImagickPixel|string $background_color) : bool {}
    public function setCompression(int $compression) : bool {}
    public function setCompressionQuality(int $quality) : bool {}
    public function setFilename(string $filename) : bool {}
    public function setFormat(string $format) : bool {}
    public function setInterlaceScheme(int $interlace) : bool {}
    public function setOption(string $key, string $value) : bool {}
    public function setPage(int $width, int $height, int $x, int $y) : bool {}
    public static function setResourceLimit(int $type, int $limit) : bool {}
    public function setResolution(float $x_resolution, float $y_resolution) : bool {}
    public function setSamplingFactors(array $factors) : bool {}
    public function setSize(int $columns, int $rows) : bool {}
    public function setType(int $imgtype) : bool {}
    public function key() : int {}
    public function next() : void {}
    public function rewind() : void {}
    public function valid() : bool {}
    public function current() : \Imagick {}
    public function brightnessContrastImage(float $brightness, float $contrast, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function colorMatrixImage(array $color_matrix) : bool {}
    public function selectiveBlurImage(float $radius, float $sigma, float $threshold, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function rotationalBlurImage(float $angle, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function statisticImage(int $type, int $width, int $height, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function subimageMatch(\Imagick $image, &$offset = null, &$similarity = null, float $threshold = 0.0, int $metric = 0) : \Imagick {}
    public function similarityImage(\Imagick $image, &$offset = null, &$similarity = null, float $threshold = 0.0, int $metric = 0) : \Imagick {}
    public static function setRegistry(string $key, string $value) : bool {}
    public static function getRegistry(string $key) : false|string {}
    public static function listRegistry() : array {}
    public function morphology(int $morphology, int $iterations, \ImagickKernel $kernel, int $channel = \Imagick::CHANNEL_DEFAULT) : bool {}
    public function filter(\ImagickKernel $kernel, int $channel = \Imagick::CHANNEL_UNDEFINED) : bool {}
    public function setAntialias(bool $antialias) : void {}
    public function getAntialias() : bool {}
    public function colorDecisionListImage(string $color_correction_collection) : bool {}
    public function optimizeImageTransparency() : void {}
    public function autoGammaImage(?int $channel = \Imagick::CHANNEL_ALL) : void {}
    public function autoOrient() : void {}
    public function autoOrientate() : void {}
    public function compositeImageGravity(\Imagick $image, int $composite_constant, int $gravity) : bool {}
    public function localContrastImage(float $radius, float $strength) : bool {}
}

class ImagickDraw {

    // methods
    public function resetVectorGraphics() : bool {}
    public function getTextKerning() : float {}
    public function setTextKerning(float $kerning) : bool {}
    public function getTextInterwordSpacing() : float {}
    public function setTextInterwordSpacing(float $spacing) : bool {}
    public function getTextInterlineSpacing() : float {}
    public function setTextInterlineSpacing(float $spacing) : bool {}
    public function __construct() {}
    public function setFillColor(\ImagickPixel|string $fill_color) : bool {}
    public function setFillAlpha(float $alpha) : bool {}
    public function setResolution(float $resolution_x, float $resolution_y) : bool {}
    public function setStrokeColor(\ImagickPixel|string $color) : bool {}
    public function setStrokeAlpha(float $alpha) : bool {}
    public function setStrokeWidth(float $width) : bool {}
    public function clear() : bool {}
    public function circle(float $origin_x, float $origin_y, float $perimeter_x, float $perimeter_y) : bool {}
    public function annotation(float $x, float $y, string $text) : bool {}
    public function setTextAntialias(bool $antialias) : bool {}
    public function setTextEncoding(string $encoding) : bool {}
    public function setFont(string $font_name) : bool {}
    public function setFontFamily(string $font_family) : bool {}
    public function setFontSize(float $point_size) : bool {}
    public function setFontStyle(int $style) : bool {}
    public function setFontWeight(int $weight) : bool {}
    public function getFont() : string {}
    public function getFontFamily() : string {}
    public function getFontSize() : float {}
    public function getFontStyle() : int {}
    public function getFontWeight() : int {}
    public function destroy() : bool {}
    public function rectangle(float $top_left_x, float $top_left_y, float $bottom_right_x, float $bottom_right_y) : bool {}
    public function roundRectangle(float $top_left_x, float $top_left_y, float $bottom_right_x, float $bottom_right_y, float $rounding_x, float $rounding_y) : bool {}
    public function ellipse(float $origin_x, float $origin_y, float $radius_x, float $radius_y, float $angle_start, float $angle_end) : bool {}
    public function skewX(float $degrees) : bool {}
    public function skewY(float $degrees) : bool {}
    public function translate(float $x, float $y) : bool {}
    public function line(float $start_x, float $start_y, float $end_x, float $end_y) : bool {}
    public function arc(float $start_x, float $start_y, float $end_x, float $end_y, float $start_angle, float $end_angle) : bool {}
    public function matte(float $x, float $y, int $paint) : bool {}
    public function polygon(array $coordinates) : bool {}
    public function point(float $x, float $y) : bool {}
    public function getTextDecoration() : int {}
    public function getTextEncoding() : false|string {}
    public function getFontStretch() : int {}
    public function setFontStretch(int $stretch) : bool {}
    public function setStrokeAntialias(bool $enabled) : bool {}
    public function setTextAlignment(int $align) : bool {}
    public function setTextDecoration(int $decoration) : bool {}
    public function setTextUnderColor(\ImagickPixel|string $under_color) : bool {}
    public function setViewbox(int $left_x, int $top_y, int $right_x, int $bottom_y) : bool {}
    public function clone() : \ImagickDraw {}
    public function affine(array $affine) : bool {}
    public function bezier(array $coordinates) : bool {}
    public function composite(int $composite, float $x, float $y, float $width, float $height, \Imagick $image) : bool {}
    public function color(float $x, float $y, int $paint) : bool {}
    public function comment(string $comment) : bool {}
    public function getClipPath() : false|string {}
    public function getClipRule() : int {}
    public function getClipUnits() : int {}
    public function getFillColor() : \ImagickPixel {}
    public function getFillOpacity() : float {}
    public function getFillRule() : int {}
    public function getGravity() : int {}
    public function getStrokeAntialias() : bool {}
    public function getStrokeColor() : \ImagickPixel {}
    public function getStrokeDashArray() : array {}
    public function getStrokeDashOffset() : float {}
    public function getStrokeLineCap() : int {}
    public function getStrokeLineJoin() : int {}
    public function getStrokeMiterLimit() : int {}
    public function getStrokeOpacity() : float {}
    public function getStrokeWidth() : float {}
    public function getTextAlignment() : int {}
    public function getTextAntialias() : bool {}
    public function getVectorGraphics() : string {}
    public function getTextUnderColor() : \ImagickPixel {}
    public function pathClose() : bool {}
    public function pathCurveToAbsolute(float $x1, float $y1, float $x2, float $y2, float $x, float $y) : bool {}
    public function pathCurveToRelative(float $x1, float $y1, float $x2, float $y2, float $x, float $y) : bool {}
    public function pathCurveToQuadraticBezierAbsolute(float $x1, float $y1, float $x_end, float $y) : bool {}
    public function pathCurveToQuadraticBezierRelative(float $x1, float $y1, float $x_end, float $y) : bool {}
    public function pathCurveToQuadraticBezierSmoothAbsolute(float $x, float $y) : bool {}
    public function pathCurveToQuadraticBezierSmoothRelative(float $x, float $y) : bool {}
    public function pathCurveToSmoothAbsolute(float $x2, float $y2, float $x, float $y) : bool {}
    public function pathCurveToSmoothRelative(float $x2, float $y2, float $x, float $y) : bool {}
    public function pathEllipticArcAbsolute(float $rx, float $ry, float $x_axis_rotation, bool $large_arc, bool $sweep, float $x, float $y) : bool {}
    public function pathEllipticArcRelative(float $rx, float $ry, float $x_axis_rotation, bool $large_arc, bool $sweep, float $x, float $y) : bool {}
    public function pathFinish() : bool {}
    public function pathLineToAbsolute(float $x, float $y) : bool {}
    public function pathLineToRelative(float $x, float $y) : bool {}
    public function pathLineToHorizontalAbsolute(float $x) : bool {}
    public function pathLineToHorizontalRelative(float $x) : bool {}
    public function pathLineToVerticalAbsolute(float $y) : bool {}
    public function pathLineToVerticalRelative(float $y) : bool {}
    public function pathMoveToAbsolute(float $x, float $y) : bool {}
    public function pathMoveToRelative(float $x, float $y) : bool {}
    public function pathStart() : bool {}
    public function polyline(array $coordinates) : bool {}
    public function popClipPath() : bool {}
    public function popDefs() : bool {}
    public function popPattern() : bool {}
    public function pushClipPath(string $clip_mask_id) : bool {}
    public function pushDefs() : bool {}
    public function pushPattern(string $pattern_id, float $x, float $y, float $width, float $height) : bool {}
    public function render() : bool {}
    public function rotate(float $degrees) : bool {}
    public function scale(float $x, float $y) : bool {}
    public function setClipPath(string $clip_mask) : bool {}
    public function setClipRule(int $fillrule) : bool {}
    public function setClipUnits(int $pathunits) : bool {}
    public function setFillOpacity(float $opacity) : bool {}
    public function setFillPatternUrl(string $fill_url) : bool {}
    public function setFillRule(int $fillrule) : bool {}
    public function setGravity(int $gravity) : bool {}
    public function setStrokePatternUrl(string $stroke_url) : bool {}
    public function setStrokeDashOffset(float $dash_offset) : bool {}
    public function setStrokeLineCap(int $linecap) : bool {}
    public function setStrokeLineJoin(int $linejoin) : bool {}
    public function setStrokeMiterLimit(int $miterlimit) : bool {}
    public function setStrokeOpacity(float $opacity) : bool {}
    public function setVectorGraphics(string $xml) : bool {}
    public function pop() : bool {}
    public function push() : bool {}
    public function setStrokeDashArray(?array $dashes) : bool {}
    public function getOpacity() : float {}
    public function setOpacity(float $opacity) : bool {}
    public function getFontResolution() : array {}
    public function setFontResolution(float $x, float $y) : bool {}
    public function getBorderColor() : \ImagickPixel {}
    public function setBorderColor(\ImagickPixel|string $color) : bool {}
    public function setDensity(string $density) : bool {}
    public function getDensity() : ?string {}
    public function getTextDirection() : int {}
    public function setTextDirection(int $direction) : bool {}
}

class ImagickDrawException extends \Exception {

    // properties
    protected $message;
    protected $code;
    protected $file;
    protected $line;
}

class ImagickException extends \Exception {

    // properties
    protected $message;
    protected $code;
    protected $file;
    protected $line;
}

class ImagickKernel {

    // methods
    public function addKernel(\ImagickKernel $kernel) : void {}
    public function addUnityKernel(float $scale) : void {}
    public static function fromBuiltin(int $kernel, string $shape) : \ImagickKernel {}
    public static function fromMatrix(array $matrix, ?array $origin = null) : \ImagickKernel {}
    public function getMatrix() : array {}
    public function scale(float $scale, ?int $normalize_kernel = null) : void {}
    public function separate() : array {}
}

class ImagickKernelException extends \Exception {

    // properties
    protected $message;
    protected $code;
    protected $file;
    protected $line;
}

class ImagickPixel {

    // methods
    public function __construct(?string $color = null) {}
    public function clear() : bool {}
    public function destroy() : bool {}
    public function getColor(int $normalized = 0) : array {}
    public function getColorAsString() : string {}
    public function getColorCount() : int {}
    public function getColorQuantum() : array {}
    public function getColorValue(int $color) : float {}
    public function getColorValueQuantum(int $color) : int {}
    public function getHSL() : array {}
    public function getIndex() : int {}
    public function isPixelSimilar(\ImagickPixel|string $color, float $fuzz) : ?bool {}
    public function isPixelSimilarQuantum(\ImagickPixel|string $color, float $fuzz_quantum_range_scaled_by_square_root_of_three) : ?bool {}
    public function isSimilar(\ImagickPixel|string $color, float $fuzz_quantum_range_scaled_by_square_root_of_three) : ?bool {}
    public function setColor(string $color) : bool {}
    public function setColorCount(int $color_count) : bool {}
    public function setColorValue(int $color, float $value) : bool {}
    public function setColorValueQuantum(int $color, int $value) : bool {}
    public function setHSL(float $hue, float $saturation, float $luminosity) : bool {}
    public function setIndex(int $index) : bool {}
    public function setColorFromPixel(\ImagickPixel $pixel) : bool {}
}

class ImagickPixelException extends \Exception {

    // properties
    protected $message;
    protected $code;
    protected $file;
    protected $line;
}

class ImagickPixelIterator implements \Iterator, \Traversable {

    // methods
    public function __construct(\Imagick $imagick) {}
    public function clear() : bool {}
    public static function getPixelIterator(\Imagick $imagick) : \ImagickPixelIterator {}
    public static function getPixelRegionIterator(\Imagick $imagick, int $x, int $y, int $columns, int $rows) : \ImagickPixelIterator {}
    public function destroy() : bool {}
    public function getCurrentIteratorRow() : ?array {}
    public function getIteratorRow() : int {}
    public function getNextIteratorRow() : ?array {}
    public function getPreviousIteratorRow() : array {}
    public function key() : int {}
    public function next() : void {}
    public function rewind() : void {}
    public function current() : ?array {}
    public function newPixelIterator(\Imagick $imagick) : bool {}
    public function newPixelRegionIterator(\Imagick $imagick, int $x, int $y, int $columns, int $rows) : bool {}
    public function resetIterator() : bool {}
    public function setIteratorFirstRow() : bool {}
    public function setIteratorLastRow() : bool {}
    public function setIteratorRow(int $row) : bool {}
    public function syncIterator() : bool {}
    public function valid() : bool {}
}

class ImagickPixelIteratorException extends \Exception {

    // properties
    protected $message;
    protected $code;
    protected $file;
    protected $line;
}

}
